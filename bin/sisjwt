#!/usr/bin/env ruby
require "active_support/core_ext"
require "bundler"
require "date"
require "optparse"
require 'rubygems'

Bundler.require(:default, :development)
require "sisjwt"

# LOG_LEVEL_FATAL = 3
# LOG_LEVEL_WARN  = 2
# LOG_LEVEL_INFO  = 1
# LOG_LEVEL_DBUG  = 0
# @cur_log_level  = LOG_LEVEL_DBUG
#
# def fatal!(msg = "unspecified error, exiting.", ec: 1)
#   $stderr.puts("FATAL: #{msg}") unless @cur_log_level < LOG_LEVEL_FATAL
#   exit ec
# end
#
# def warn(msg)
#   return if @cur_log_level < LOG_LEVEL_WARN
#   $stderr.puts "WARN : #{msg}"
# end
#
# def info(msg)
#   return if @cur_log_level < LOG_LEVEL_INFO
#   $stderr.puts msg
# end
#
# def debug(msg)
#   return if @cur_log_level < LOG_LEVEL_DBUG
#   $stderr.puts msg
# end
class App
  attr_accessor :strict_mode, :jwt_opts, :logger
  # attr_accessor :token_type, :key_alg, :key, :aws_region
  # attr_accessor :token_lifetime, :iss, :aud, :iat, :exp
  (
    %i(token_type key_alg key_id aws_region token_lifetime iss aud iat exp) +
    %i(token_type= key_alg= key_id= aws_region= token_lifetime= iss= aud= iat= exp=) +
    %i(validate valid? errors error_messages)
  ).each do |m|
    delegate m, to: :jwt_opts
  end

  def initialize(logger: nil)
    # require 'pry'; binding.pry
    @jwt_opts = ::Sisjwt::SisJwtOptions.defaults(mode: :verify)
    @strict_mode = true
    @logger = logger || Logger.new($stderr, level: :warn)
    @logger.debug "Is Prod: #{production?}"
    # token_type = production? ? "SISKMS" : "SISKMSd"
    # @key_alg = "ECDSA_SHA_256"
    # @key = production? ? ENV['SIGNING_KMS_KEY_ARN'] : ENV.fetch('SISKMS_DEV_SECRET', 's3cr37')
    # @aws_region = ENV.fetch('SIGNING_KMS_KEY_REGION', ENV.fetch('AWS_REGION', 'us-west-2'))
    # @token_lifetime = 3_600
    # @iss = ENV.fetch("SISKMS_ISS", "SIS")
    # @aud = ENV.fetch("SISKMS_AUD", "SIS")
    # @iat = nil
    # @exp = nil
  end

  def to_h
    {
      production: production?,
      token_type: token_type,
      key_alg: key_alg,
      key_id: key_id,
      aws_region: aws_region,
      token_lifetime: token_lifetime,
      iss: iss,
      aud: aud,
      iat: iat,
      exp: exp,
    }
  end

  def production?
    @jwt_opts.class.production_env?
  end

  # Transforms array like:
  #    [ "k=v", "val", "other=opt" ]
  # into
  #    { "k" => "v", "val" => nil, "other" => "opt" }
  def array_to_hash(array)
    array.map do |v|
      k,v = v.split("=", 2)
      [k.strip, v&.strip]
    end.to_h.with_indifferent_access
  end

  def sign_token(args = ARGV)
    @logger.info "SIGN TOKEN"
    args = array_to_hash(args) if args.is_a?(Array)

    @logger.debug "config: #{to_h}"
    @logger.debug  "  args: #{args}"

    sisjwt = ::Sisjwt::SisJwt.new(@jwt_opts)
    token = sisjwt.encode(args)

    # We explictitly do not use logger here because we want it to goto stdout
    $stdout.puts token
  end

  def verify_token(token = ARGV[0])
    @logger.info "VERIFY TOKEN"

    @logger.debug "config: #{to_h}"
    @logger.debug " token: #{token}"

    sisjwt = ::Sisjwt::SisJwt.new(@jwt_opts)
    data = sisjwt.verify(token)

    # We explictitly do not use logger here because we want it to goto stdout
    # todo: ensure this is valid json
    $stdout.puts data.to_json
  end

  ################################################################################
  # Option Parsing
  ################################################################################

  # Creates a new App instance from given options
  def self.from_options!(options=ARGV, logger: nil)
    app = App.new(logger: logger)

    OptionParser.new do |opts|
      opts.banner = "sisjwt - Sign in Solutions JWT Generator"

      opts.on("--[no-]strict-mode", "Turn off strict mode to allow specifying invalid values, default strict: #{app.strict_mode}") do |v|
        app.strict_mode = v
      end

      opts.on("-t", "--type=val", "Type of Token to Generate, default #{app.token_type}") do |v|
        app.token_type = v
      end

      opts.on("-a", "--alg=val", "KMS Algorithm to use to sign the token, default #{app.key_alg}") do |v|
        app.key_alg = v
      end

      opts.on("-r", "--region=val", "KMS Region to use to sign the token, default #{app.aws_region}") do |v|
        app.aws_region = v
      end

      opts.on("-e", "--expires=secs", OptionParser::DecimalInteger, "Number of seconds that the key should be valid for (used to calculate `exp` value), default #{app.token_lifetime}s") do |v|
        app.aws_region = v.to_i
      end

      opts.on "--aud=VAL", "Token AUDience (Should be SIS company acronym: SIE, SIC, etc), default #{app.aud}" do |v|
        app.aud = v
      end

      opts.on("--iss=VAL", "Token ISSuer (Should be SIS company acronym: SIE, SIC, etc), default #{app.iss}") do |v|
        app.iss = v
      end

      opts.on("--exp=VAL", "Token EXPiration, unix time, default #{app.exp}") do |v|
        app.exp = v
      end

      opts.on("--ttl=VAL", "Token Time To Live, seconds, default #{app.token_lifetime}s") do |v|
        app.exp = v
      end
    end.parse!(options)
    app.validate
    app
  end
end

################################################################################
# Main
################################################################################
@logger = Logger.new($stderr, progname: 'sisjwt', level: :warn)

app = App.from_options!(ARGV, logger: @logger)

if ARGV.empty?
  app.help
  exit 1
end

# Validation
if (msg = app.error_messages).present?
  if app.strict_mode
    @logger.fatal msg
    exit 1
  else
    @logger.warn msg
  end
end

# Command Processing
if ARGV[0] == "debug"
  @logger.debug! # <-- Force logger into debug mode for debug output
  @logger.debug "ARGS ->#{app.to_h}<-"
  x=0
  while arg=ARGV.shift
    @logger.debug "Shift[#{x}]->#{arg}"
    x += 1
  end
  @logger.debug "\nValid: #{app.valid?}"
  exit 127
end

cmd = ARGV.shift
case cmd
when "sign"
  app.sign_token
when "verify"
  app.verify_token
else
  @logger.fatal "Unknown command: #{cmd}"
  exit 1
end
